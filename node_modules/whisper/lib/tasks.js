(function(){
  var Base, Promise, makeError, sequentially, taskExistsE, inexistentTaskE, resolve, asAction, allTasks, Task, task, slice$ = [].slice;
  Base = require('boo').Base;
  Promise = require('cassie').Promise;
  makeError = require('flaw');
  sequentially = require('cassie/src/sequencing');
  taskExistsE = function(task){
    return makeError('<task-exists-e>', "A task named \"" + task.name + "\" has already been registered:\n\n" + task.name + " (" + task.dependencies.join(', ') + ")\n    " + (task.description || ''));
  };
  inexistentTaskE = function(name){
    return makeError('<inexistent-task-e>', "The task \"" + name + "\" has not been registered.");
  };
  resolve = function(name){
    switch (false) {
    case !(name in allTasks):
      return allTasks[name];
    default:
      throw inexistentTaskE(name);
    }
  };
  asAction = function(task){
    return function(){
      var as;
      as = slice$.call(arguments);
      return task.execute.apply(task, as);
    };
  };
  allTasks = {};
  Task = Base.derive({
    init: function(name, deps, description, fun){
      this.name = name;
      this.description = description;
      this.fun = fun;
      this._executed = false;
      this.async = false;
      this.promise = Promise.make();
      this.dependencies = deps.map(resolve);
      this.register();
      return this;
    },
    execute: function(env){
      var args, this$ = this;
      args = slice$.call(arguments, 1);
      if (!this._executed) {
        return sequentially.apply(null, this.dependencies.map(asAction).concat([function(){
          var result;
          this$._executed = true;
          result = this$.fun.apply(this$, [env].concat(slice$.call(args)));
          process.nextTick(function(){
            if (!this$.async) {
              return this$.promise.bind(result);
            }
          });
          return this$.promise;
        }]));
      } else {
        return this.promise;
      }
    },
    register: function(){
      switch (false) {
      case !(this.name in allTasks):
        throw taskExistsE(this);
      default:
        return allTasks[this.name] = this;
      }
    }
  });
  task = curry$(function(name, deps, desc, fun){
    return Task.make(name, deps, desc, fun);
  });
  module.exports = {
    Task: Task,
    task: task,
    allTasks: allTasks,
    resolve: resolve
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
